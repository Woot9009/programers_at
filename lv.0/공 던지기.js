//머쓱이는 친구들과 동그랗게 서서 공 던지기 게임을 하고 있습니다.
//공은 1번부터 던지며 오른쪽으로 한 명을 건너뛰고 그다음 사람에게만 던질 수 있습니다.
//친구들의 번호가 들어있는 정수 배열 numbers와 정수 K가 주어질 때,
//k번째로 공을 던지는 사람의 번호는 무엇인지 return 하도록 solution 함수를 완성해보세요.
//예를 들어 numbers=[1,2,3,4,5,6]; k=5;면 1,3,5,1,3 순서로 공을 던져 3이 answer
//numbers=[1,2,3,4]; k=6;이면 1,3,2,1,3,1 순서로 공을 던져 1이 answer

function solution(numbers, k) {
  let cnt = 1;
  
  for(let i=0; ; i+=2) {
      i %= numbers.length;
      const item = numbers[i];
      if (cnt === k){
          return item;
      }
      cnt++;
  }
}

/*
공던지기가 배열의 끝을 넘어갈 때 다시 처음으로 돌아가서 던지는 것이 포인트
보통 이런 구조에서는 나머지 연산자를 많이 활용함(넘어갈 때 나머지와 인덱스 번호가 일치함!!)

1. 처음 던질때의 회수 의미로 cnt=1;
2. k번째만 리턴하면 되므로 굳이 for문의 조건식은 필요 없음
3. 인덱스0부터 시작해서 +2만큼의 인덱스로 공을 던지므로 증감값은 i+=2
4. number.length로 나눈 나머지가 현재 공을 던지는 요소
5. 던진 회수cnt를 1씩 증가시키다가 cnt === k인 순간이 정답
*/